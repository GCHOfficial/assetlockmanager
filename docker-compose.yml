services:
  api:
    build: ./server
    container_name: lock_api
    ports:
      - "5000:5000" # Map host port 5000 to container port 5000 (where gunicorn listens)
    env_file:
      - .env # Load environment variables from .env file
    environment:
      # Make Flask CLI find the app
      FLASK_APP: app.py 
      # Construct DATABASE_URI from .env variables
      DATABASE_URI: postgresql://${POSTGRES_USER:-locks_user}:${POSTGRES_PASSWORD:-password}@postgres:5432/${POSTGRES_DB:-locks_db}
      # RATELIMIT_STORAGE_URI is already set in .env
      # Optional JWT expiration and Initial Admin vars are also loaded from .env if set
    depends_on:
      - postgres
      - redis
    volumes:
      # Optional: Mount code for development (comment out for production build)
      # - ./API:/app
      # Mount database file if using SQLite (Not needed for PostgreSQL)
      # - ./API/locks.db:/app/locks.db # Example if using SQLite
      - api_logs:/app/logs # Example volume for logs if app logs to /app/logs

  postgres:
    image: postgres:15-alpine # Using version 15 alpine image
    container_name: lock_db
    env_file:
      - .env # Load POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
    volumes:
      - pgdata:/var/lib/postgresql/data # Persist data
    ports:
      # Optional: Expose port 5432 to host for debugging/direct access
      - "5432:5432"
    healthcheck:
        test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-locks_user} -d ${POSTGRES_DB:-locks_db}"]
        interval: 10s
        timeout: 5s
        retries: 5

  redis:
    image: redis:7-alpine # Using version 7 alpine image
    container_name: lock_redis
    ports:
      # Optional: Expose port 6379 to host for debugging
      - "6379:6379"
    volumes:
      - redisdata:/data # Persist data (optional for rate limiting, depends on needs)

volumes:
  pgdata:
  redisdata:
  api_logs: # Define the log volume if used above